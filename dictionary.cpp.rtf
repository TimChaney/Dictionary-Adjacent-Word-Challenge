{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\sa380\ql\qnatural\pardirnatural

\f0\fs22 \cf0 \expnd0\expndtw0\kerning0
#include <iostream.h>\uc0\u8232 #include <fstream.h>\u8232 #include <vector.h>\u8232 #include <set.h>\u8232 #include <map.h>\
using namespace std;\
//****\uc0\u8232 //\'a0\'a0 Exception is a simple class that enables printing error messages when invalid conditions arise.\u8232 //****\u8232 class Exception\u8232 \{\u8232 \'a0 public:\u8232 \'a0\'a0 Exception(const string& exceptionString) : ExceptionString(exceptionString) \{\};\u8232 \'a0\'a0 virtual void print() const;\
\'a0 private:\uc0\u8232 \'a0\'a0 string ExceptionString;\u8232 \};\
void\uc0\u8232 Exception::print() const\u8232 \{\u8232 \'a0 cout << ExceptionString << endl;\u8232 \}\
//****\uc0\u8232 //\'a0\'a0 AdjChecker is an abstract base class that specifies an interface for determining if two specified words are adjacent.\u8232 //****\u8232 class AdjChecker\u8232 \{\u8232 \'a0 public:\u8232 \'a0\'a0 AdjChecker() \{\};\u8232 \'a0\'a0 virtual bool isAdjacent(const string& s1, const string& s2) const = 0;\u8232 \};\
//****\uc0\u8232 //\'a0\'a0 AdjWordDiffLengthChecker is a singleton class that determines if two words that differ in length by one are adjacent.\u8232 //****\u8232 class AdjWordDiffLengthChecker : public AdjChecker\u8232 \{\u8232 \'a0 public:\u8232 \'a0\'a0\'a0 static AdjWordDiffLengthChecker& getInstance();\u8232 \'a0\'a0\'a0 bool isAdjacent(const string& s1, const string& s2) const;\u8232 \'a0 private:\u8232 \'a0\'a0\'a0 AdjWordDiffLengthChecker() : AdjChecker() \{\};\u8232 \'a0\'a0\'a0 AdjWordDiffLengthChecker(const AdjWordDiffLengthChecker&) \{\};\u8232 \'a0\'a0\'a0 AdjWordDiffLengthChecker& operator=(const AdjWordDiffLengthChecker&) \{ return *this; \};\u8232 \'a0\'a0\'a0 static AdjWordDiffLengthChecker* TheAdjWordDiffLengthChecker;\u8232 \};\
AdjWordDiffLengthChecker&\uc0\u8232 AdjWordDiffLengthChecker::getInstance()\u8232 \{\u8232 \'a0\'a0\'a0 if ( TheAdjWordDiffLengthChecker == 0 )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TheAdjWordDiffLengthChecker = new AdjWordDiffLengthChecker;\u8232 \'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0 return *TheAdjWordDiffLengthChecker;\u8232 \};\
bool\uc0\u8232 AdjWordDiffLengthChecker::isAdjacent(const string& word1, const string& word2) const\u8232 \{\u8232 \'a0\'a0 // Adjacent words include words that can be made by adding or removing one letter to make a new word.\u8232 \'a0\'a0 // To determine if two words of different length are adjacent, find the longer word and progressively\u8232 \'a0\'a0 // remove each letter and compare the subsequent word with the shorter word. If the two words are the same,\u8232 \'a0\'a0 // they are adjacent.\u8232 \'a0\'a0 std::string longerWord(word1);\u8232 \'a0\'a0 std::string shorterWord(word2);\
\'a0\'a0 bool adjacent = false;\
\'a0\'a0 if ( word2.length() > word1.length() )\uc0\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 longerWord = word2;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 shorterWord = word1;\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 unsigned int i = 0;\u8232 \'a0\'a0 // Stop when determine that the words are adjacent or run out of permutations \u8232 \'a0\'a0 while ( adjacent == false && i < longerWord.length() )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 std::string newWord = longerWord.substr(0,i) + longerWord.substr(i+1,longerWord.size()-1);\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 adjacent = (newWord == shorterWord);\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 i++;\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 return adjacent;\u8232 \};\
//****\uc0\u8232 //\'a0\'a0 AdjWordSameLengthChecker is a singleton class that determines if two words of equal length are adjacent.\u8232 //****\u8232 class AdjWordSameLengthChecker : public AdjChecker\u8232 \{\u8232 \'a0 public:\u8232 \'a0\'a0\'a0 static AdjWordSameLengthChecker& getInstance();\u8232 \'a0\'a0\'a0 bool isAdjacent(const string& s1, const string& s2) const;\u8232 \'a0 private:\u8232 \'a0\'a0\'a0 AdjWordSameLengthChecker() : AdjChecker() \{\};\u8232 \'a0\'a0\'a0 AdjWordSameLengthChecker(const AdjWordSameLengthChecker&) \{\};\u8232 \'a0\'a0\'a0 AdjWordSameLengthChecker& operator=(const AdjWordSameLengthChecker&) \{ return *this; \};\u8232 \'a0\'a0\'a0 static AdjWordSameLengthChecker* TheAdjWordSameLengthChecker;\u8232 \};\
AdjWordSameLengthChecker&\uc0\u8232 AdjWordSameLengthChecker::getInstance()\u8232 \{\u8232 \'a0\'a0\'a0 if ( TheAdjWordSameLengthChecker == 0 )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TheAdjWordSameLengthChecker = new AdjWordSameLengthChecker;\u8232 \'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0 return *TheAdjWordSameLengthChecker;\u8232 \};\
bool\uc0\u8232 AdjWordSameLengthChecker::isAdjacent(const std::string& word1, const std::string& word2) const\u8232 \{\u8232 \'a0 // Two words of the same length are adjacent if all the letters are the same in each position except one.\u8232 \'a0 // Compare the corresponding letters in the specified words, and if only one difference is found, they\u8232 \'a0 // are adjacent.\u8232 \'a0\'a0 unsigned int numDiff = 0;\u8232 \'a0\'a0 for (unsigned int i = 0; i < word1.length(); i++)\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 if ( word1[i] != word2[i] )\u8232 \'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 numDiff++;\u8232 \'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 return (numDiff == 1);\u8232 \}\
//****\uc0\u8232 //\'a0\'a0 AdjWordCheckerFactory is a singleton class responsible for determining if two words are adjacent to one another.\u8232 //\'a0\'a0 This class encapsulates the details about how adjacency is determined from any class that uses it.\u8232 //****\u8232 class AdjWordCheckerFactory\u8232 \{\u8232 \'a0\'a0 public:\u8232 \'a0\'a0\'a0\'a0\'a0 static AdjWordCheckerFactory& getInstance();\u8232 \'a0\'a0\'a0\'a0\'a0 bool isAdjacent(const string& word1, const string& word2) const;\
\'a0\'a0 private:\uc0\u8232 \'a0\'a0\'a0\'a0\'a0 AdjWordCheckerFactory() \{ \};\u8232 \'a0\'a0\'a0\'a0\'a0 AdjWordCheckerFactory(const AdjWordCheckerFactory&) \{\};\u8232 \'a0\'a0\'a0\'a0\'a0 AdjWordCheckerFactory& operator=(const AdjWordCheckerFactory&) \{ return *this; \};\u8232 \'a0\'a0\'a0\'a0\'a0 static AdjWordCheckerFactory* TheAdjWordCheckerFactory;\u8232 \};\
// Initialize the static data members\uc0\u8232 AdjWordCheckerFactory* AdjWordCheckerFactory::TheAdjWordCheckerFactory = 0;\u8232 AdjWordSameLengthChecker* AdjWordSameLengthChecker::TheAdjWordSameLengthChecker = 0;\u8232 AdjWordDiffLengthChecker* AdjWordDiffLengthChecker::TheAdjWordDiffLengthChecker = 0;\
AdjWordCheckerFactory&\uc0\u8232 AdjWordCheckerFactory::getInstance()\u8232 \{\u8232 \'a0\'a0\'a0 if ( TheAdjWordCheckerFactory == 0 )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TheAdjWordCheckerFactory = new AdjWordCheckerFactory;\u8232 \'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0 return *TheAdjWordCheckerFactory;\u8232 \};\
bool\uc0\u8232 AdjWordCheckerFactory::isAdjacent(const std::string& word1, const std::string& word2) const\u8232 \{\u8232 \'a0\'a0\'a0 // Use the appropriate AdjChecker subclass to determine the adjacency of two words\u8232 \'a0\'a0\'a0 bool adjacent = false;\u8232 \'a0\'a0\'a0 int lengthDiff = abs(word1.length()-word2.length());\u8232 \'a0\'a0\'a0 switch (lengthDiff)\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 0:\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 adjacent = AdjWordSameLengthChecker::getInstance().isAdjacent(word1,word2);\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 1:\'a0 \u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 adjacent = AdjWordDiffLengthChecker::getInstance().isAdjacent(word1,word2);\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break; \u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // If the words differ in length by 2 or more, they cannot be adjacent by definition.\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 default:\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\u8232 \'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0 return adjacent;\u8232 \}\
//****\uc0\u8232 //\'a0\'a0 Dictionary reads a file with one word per line and builds a associative array between each word and its adjacent words.\u8232 //****\u8232 class Dictionary\u8232 \{\u8232 \'a0\'a0 public:\u8232 \'a0\'a0\'a0\'a0\'a0 Dictionary(const string& filename);\u8232 \'a0\'a0\'a0\'a0\'a0 const string& getDictName() const \{ return DictName; \};\u8232 \'a0\'a0\'a0\'a0\'a0 unsigned int getNumWords() const \{ return Words.size(); \};\u8232 \'a0\'a0\'a0\'a0\'a0 bool exists(const string& word) const;\u8232 \'a0\'a0\'a0\'a0\'a0 const set<string>& getWords() const \{ return Words; \};\
\'a0\'a0\'a0\'a0\'a0 void add(const string& s1, const string& s2);\uc0\u8232 \'a0\'a0\'a0\'a0\'a0 vector<string>& getAssociations(const string& s, vector<string>& assns) const;\
\'a0\'a0 protected:\
\'a0\'a0\'a0\'a0\'a0 void add(const string& s1, const string& s2, map<string,vector<string>* >::const_iterator& iter);\uc0\u8232 \'a0\'a0\'a0\'a0\'a0 \u8232 \'a0\'a0 private:\u8232 \'a0\'a0\'a0\'a0\'a0 string DictName;\u8232 \'a0\'a0\'a0\'a0\'a0 set<string> Words;\u8232 \'a0\'a0\'a0\'a0\'a0 map<string,vector<string>* > TheAssociationMap;\u8232 \};\
Dictionary::Dictionary(const std::string& filename)\uc0\u8232 \'a0: DictName(filename)\u8232 \{\u8232 \'a0\'a0 ifstream dictionary;\u8232 \'a0\'a0 dictionary.open(filename.data(), ios::nocreate);\u8232 \'a0\'a0 if (dictionary.fail() == true)\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 string exceptionString = "Dictionary File: " + DictName + " not found!";\u8232 \'a0\'a0\'a0\'a0\'a0 throw Exception(exceptionString);\u8232 \'a0\'a0 \}\
\'a0\'a0 // Read each word and add it to the word list\uc0\u8232 \'a0\'a0 string word;\u8232 \'a0\'a0 while ( dictionary.eof() == false )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 dictionary >> word;\u8232 \'a0\'a0\'a0\'a0 \u8232 \'a0\'a0\'a0\'a0\'a0 // Find the adjacent words to the current word from the words read from the Dictionary so far\u8232 \'a0\'a0\'a0\'a0\'a0 set<string>::const_iterator iter = Words.begin();\u8232 \'a0\'a0\'a0\'a0\'a0 while ( iter != Words.end() )\u8232 \'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if ( AdjWordCheckerFactory::getInstance().isAdjacent(*iter,word) == true )\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 add(*iter,word); // Add an association between the two words\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 iter++;\u8232 \'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0 Words.insert(word);\u8232 \'a0\'a0 \}\u8232 \};\
bool\uc0\u8232 Dictionary::exists(const std::string& word) const\u8232 \{\u8232 \'a0\'a0 std::set<std::string>::const_iterator iter;\u8232 \'a0\'a0 if ( (iter = Words.find(word)) == Words.end() )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 return false;\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 return true;\u8232 \};\
vector<string>&\uc0\u8232 Dictionary::getAssociations(const string& s, vector<string>& assns) const\u8232 \{\u8232 \'a0\'a0 map<string,vector<string>* >::const_iterator iter = TheAssociationMap.find(s);\u8232 \'a0\'a0 if ( iter != TheAssociationMap.end() )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 assns = *(iter->second);\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 return assns;\u8232 \};\
void\uc0\u8232 Dictionary::add(const string& s1, const string& s2)\u8232 \{\u8232 \'a0\'a0 // Make sure adjacent words are associated with each other bidirectionally\u8232 \'a0\'a0 map<string,vector<string>* >::const_iterator iter1 = TheAssociationMap.find(s1);\u8232 \'a0\'a0 map<string,vector<string>* >::const_iterator iter2 = TheAssociationMap.find(s2);\
\'a0\'a0 add(s1,s2,iter1);\uc0\u8232 \'a0\'a0 add(s2,s1,iter2);\u8232 \};\
void\uc0\u8232 Dictionary::add(const string& s1, const string& s2, map<string,vector<string>* >::const_iterator& iter)\u8232 \{\u8232 \'a0\'a0 if ( iter == TheAssociationMap.end() )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 // For a new word, add it and allocate space for its list of adjacent words\u8232 \'a0\'a0\'a0\'a0\'a0 vector<string>* strs = new vector<string>();\u8232 \'a0\'a0\'a0\'a0\'a0 strs->push_back(s2);\u8232 \'a0\'a0\'a0\'a0\'a0 TheAssociationMap[s1] = strs;\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 else\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 // For existing words, add the adjacent word to its list\u8232 \'a0\'a0\'a0\'a0\'a0 iter->second->push_back(s2);\u8232 \'a0\'a0 \}\u8232 \};\
//****\uc0\u8232 //\'a0\'a0 ChainGenerator finds and prints a viable path between the specified words, first and last, if one exists;\u8232 //\'a0\'a0 otherwise, an Exception is thrown. The path found is not guaranteed to be the shortest path.\u8232 //****\
class ChainGenerator\uc0\u8232 \{\u8232 \'a0 public:\u8232 \'a0\'a0\'a0 ChainGenerator(Dictionary& dict, const string& first, const string& last);\
\'a0 protected:\uc0\u8232 \'a0\'a0\'a0 void printPath() const;\u8232 \'a0\'a0\'a0 void validateWord(const string& word) const;\u8232 \'a0\'a0\'a0 void swapWords();\u8232 \'a0\'a0\'a0 void addPath(map<string,string>& links);\u8232 \'a0\'a0\'a0 void buildChain(const string& currWord, set<string>& usedWords, map<string,string>& links);\
\'a0 private:\uc0\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 vector<string> BestPaths;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 bool Finished;\
\'a0\'a0\'a0\'a0\'a0\'a0 Dictionary& TheDictionary;\uc0\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 string FirstWord;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 string LastWord;\u8232 \};\
ChainGenerator::ChainGenerator(Dictionary& dict, const string& first, const string& last)\uc0\u8232 \'a0: TheDictionary(dict)\u8232 \'a0, FirstWord(first)\u8232 \'a0, LastWord(last)\u8232 \'a0, Finished(false)\u8232 \{\u8232 \'a0\'a0 // Check existence of both words in Dictionary\u8232 \'a0\'a0 validateWord(FirstWord);\u8232 \'a0\'a0 validateWord(LastWord);\
\'a0\'a0 // For efficiency, start with the word that has the fewest adjacent words\uc0\u8232 \'a0\'a0 swapWords();\
\'a0\'a0 set<string> usedWords;\uc0\u8232 \'a0\'a0 map<string,string> links;\u8232 \'a0\'a0 links[FirstWord] = "*"; // Add a Terminating link for the FirstWord\u8232 \'a0\'a0 buildChain(FirstWord, usedWords, links);\
\'a0\'a0 printPath();\uc0\u8232 \}\
/****\uc0\u8232 \'a0 buildChain is a recursive function that searches the adjacent words of the current word until the\u8232 \'a0 LastWord is found or there are no more adjacent words to traverse\u8232 ***/\u8232 void\u8232 ChainGenerator::buildChain(const string& currWord, set<string>& usedWords, map<string,string>& links)\u8232 \{\u8232 \'a0\'a0 vector<string> adjWords;\
\'a0\'a0 TheDictionary.getAssociations(currWord, adjWords); // Get current word's adjacencies\uc0\u8232 \'a0\'a0 if ( adjWords.size() > 0 ) // When there are no more adjacencies, that chain ends\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 usedWords.insert(currWord); // Keep the current chain to avoid duplication\
\'a0\'a0\'a0\'a0\'a0 for ( vector<string>::const_iterator iter = adjWords.begin(); iter != adjWords.end(); iter++ )\uc0\u8232 \'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string adjWord(*iter);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Keep building chain if LastWord is not found and not repeating a word already in chain\uc0\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if ( Finished == false && usedWords.find(adjWord) == usedWords.end() )\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 links[adjWord] = currWord;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if ( adjWord != LastWord )\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 buildChain(adjWord,usedWords,links); // Keep looking for end of chain\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // When end of chain is found, save the chain\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Finished = true;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 addPath(links);\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0 if ( Finished == false )\u8232 \'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 usedWords.erase(currWord); // Done with a chain when all adjacencies traversed\u8232 \'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0 \}\u8232 \}\u8232 void\u8232 ChainGenerator::swapWords()\u8232 \{\u8232 \'a0\'a0 vector<string> firstAssns;\u8232 \'a0\'a0 vector<string> lastAssns;\
\'a0\'a0 // For efficiency, ensure the FirstWord has the fewest adjacent words\uc0\u8232 \'a0\'a0 if ( TheDictionary.getAssociations(FirstWord,firstAssns).size() >\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TheDictionary.getAssociations(LastWord,lastAssns).size() )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 string tmp(LastWord);\u8232 \'a0\'a0\'a0\'a0\'a0 LastWord = FirstWord;\u8232 \'a0\'a0\'a0\'a0\'a0 FirstWord = tmp;\u8232 \'a0\'a0 \}\u8232 \}\
void\uc0\u8232 ChainGenerator::validateWord(const string& word) const\u8232 \{\u8232 \'a0\'a0 if ( TheDictionary.exists(word) == false )\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 string exceptionString = "Word: " + word + " not found in " + TheDictionary.getDictName();\u8232 \'a0\'a0\'a0\'a0\'a0 throw Exception(exceptionString);\u8232 \'a0\'a0 \}\u8232 \}\
void\uc0\u8232 ChainGenerator::addPath(map<string,string>& links)\u8232 \{\u8232 \'a0\'a0\'a0 string s(LastWord);\u8232 \'a0\'a0\'a0 string chain(LastWord);\
\'a0\'a0\'a0 // Build the path from the LastWord to the FirstWord\uc0\u8232 \'a0\'a0\'a0 // Print the solution. Note that for simplicity, no attempt is made to reverse the\u8232 \'a0\'a0\'a0 // path if FirstWord and LastWord were swapped.\'a0\'a0\'a0 \u8232 \'a0\'a0\'a0 while ( links.find(s)->first != FirstWord )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 s = links.find(s)->second;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 chain = s + "-" + chain;\u8232 \'a0\'a0\'a0 \} \u8232 \'a0\'a0\'a0 BestPaths.push_back(chain);\u8232 \}\
void\uc0\u8232 ChainGenerator::printPath() const\u8232 \{\u8232 \'a0\'a0\'a0 // Throw Exception is no connection exists\u8232 \'a0\'a0\'a0 if ( BestPaths.size() == 0 )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 string exceptionString = "No Connection Found: " + FirstWord + "/" + LastWord;\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 throw Exception(exceptionString);\u8232 \'a0\'a0\'a0 \}\
\'a0\'a0\'a0 // Print out the best paths\'a0\'a0\'a0 \uc0\u8232 \'a0\'a0\'a0 for ( unsigned int i = 0; i < BestPaths.size(); i++ )\u8232 \'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0 cout << BestPaths[i] << endl;\u8232 \'a0\'a0\'a0 \} \u8232 \}\
int \uc0\u8232 main(int argc, char** argv)\u8232 \{\u8232 \'a0\'a0 try\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 if ( argc < 4 )\u8232 \'a0\'a0\'a0\'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string exceptionString("Usage: rkg <Dictionary Filename> <Start Word> <End Word>");\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw Exception(exceptionString);\u8232 \'a0\'a0\'a0\'a0\'a0 \}\u8232 \'a0\'a0\'a0\'a0\'a0 string dictName(argv[1]);\u8232 \'a0\'a0\'a0\'a0\'a0 string firstWord(argv[2]);\u8232 \'a0\'a0\'a0\'a0\'a0 string lastWord(argv[3]);\u8232 \'a0\u8232 \'a0\'a0\'a0\'a0\'a0 Dictionary dict(dictName);\u8232 \'a0\'a0\'a0\'a0\'a0 ChainGenerator cg(dict,firstWord,lastWord);\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 catch (const Exception& e)\u8232 \'a0\'a0 \{\u8232 \'a0\'a0\'a0\'a0\'a0 e.print();\u8232 \'a0\'a0 \}\u8232 \'a0\'a0 return 0;\u8232 \}}